package res.algebra;

import res.*;
import java.util.*;

/* The subalgebra of the Steenrod algebra generated by Sq^1, Sq^2, Sq^4, ..., Sq^{2^n},
 * or for odd primes, B, P^1, P^p, etc. */
public class AnAlgebra implements GradedAlgebra<AnElement>
{
    final AlgebraFactory factory;
    final ResMath resmath;
    final int N;
    final int p;
    final int q;
    private final AnElement UNIT;
    
    public AnAlgebra(int p,int N) {
        this.N = N;
        this.p = p;
        this.q = 2*p-2;
        this.factory = AlgebraFactory.getInstance(p);
        UNIT = factory.AnUNIT;
        
        this.resmath = ResMath.getInstance(p);
        // precompute hopf elements
        hopf.add(new AnElement(p,factory.ModSet(factory.HOPF[0]),1));
        int pow = q;
        for(int i = 1; i <= N; i++) {
            Sq sq = factory.Sq(pow);
            AnElement elt = new AnElement(p,factory.ModSet(sq), pow);
            hopf.add(elt);
            pow *= p;
        }
    }

    ArrayList<AnElement> hopf = new ArrayList<>();

    // cache everything
    Map<Integer, Map<Sq,AnElement>> basis = new TreeMap<>();
    Map<AnElement,Map<AnElement,ModSet<AnElement>>> mult = new TreeMap<>();

    @Override public Iterable<AnElement> basis(int n)
    {
        Map<Sq,AnElement> ret = basis.get(n);
        if(ret != null) return ret.values();

        ret = new TreeMap<>();
        if(n == 0) {
            ret.put(factory.UNIT, UNIT);
        } else {
            // add a new hopf element as appropriate
            for(AnElement elt : hopf) if(elt.deg == n) {
                Sq sq = factory.Sq(n);
                ret.put(sq, elt);
            }

            // multiply everything from lower degrees
            for(int d = 1; d < n; d++) {
                for(AnElement a : basis(d)) {
                    if(! mult.containsKey(a))
                        mult.put(a, new TreeMap<>());

                    for(AnElement b : basis(n-d)) {
                        // multiply
                        ModSet<Sq> prod = factory.ModSet();
                        for(Map.Entry<Sq,Integer> e1 : a.modset.entrySet()) {
                            for(Map.Entry<Sq,Integer> e2 : b.modset.entrySet()) {
                                ModSet<Sq> sqprod = e1.getKey().times(e2.getKey());
                                int valprod = e1.getValue() * e2.getValue();
                                prod.add(sqprod, valprod);
                            }
                        }

                        // reduce by Gaussian elimination
                        Sq highKey = null;
                        int highVal = -1;
                        ModSet<AnElement> eltprod = factory.ModSet();
                        while(! prod.isEmpty()) {
                            Map.Entry<Sq,Integer> high = prod.lastEntry();
                            highKey = high.getKey();
                            highVal = high.getValue();

                            AnElement toCancel = ret.get(high.getKey());
                            if(toCancel == null) {
                                break; // should add this to the basis
                            } else {
                                eltprod.add(toCancel, highVal);
                                prod.add(toCancel.modset, -highVal);
                            }
                        }

                        // add to basis if appropriate
                        if(! prod.isEmpty()) {
                            ModSet<Sq> scaled = prod.scaled(resmath.inverse[highVal]);
                            AnElement elt = new AnElement(p,scaled,n);
                            ret.put(highKey, elt);
                            eltprod.add(elt,highVal);
//                            System.out.println("Obtained "+elt+" from "+a+" * "+b);
                        }

                        // register the product
                        mult.get(a).put(b, eltprod);
                    }
                }
            }
        }

        basis.put(n,ret);
        return ret.values();
    }

    @Override public ModSet<AnElement> times(AnElement a, AnElement b)
    {
        if(a == UNIT) return factory.ModSet(b);
        if(b == UNIT) return factory.ModSet(a);
        return mult.get(a).get(b);
    }

    @Override public AnElement unit()
    {
        return UNIT;
    }

    @Override public List<AnElement> distinguished() {
        return hopf;
    }

    @Override public int extraDegrees() { return 0; }
}


